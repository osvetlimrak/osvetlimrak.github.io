<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SVG Overlay Point Generator – KML Export</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      font-family: Arial, sans-serif;
      overflow: hidden;
      display: flex; flex-direction: column;
    }
    #map {
      width: 100%; flex-grow: 1; min-height: 200px;
      position: relative;
    }
    #controls {
      padding: 12px; background: #f4f4f4; border-top: 1px solid #ccc;
      overflow-y: auto; max-height: 40%;
      flex-shrink: 0;
    }
    .control-group {
      margin-bottom: 10px; padding-bottom: 10px;
      border-bottom: 1px dashed #ddd;
    }
    .control-group:last-child {
      border-bottom: none; margin-bottom: 0; padding-bottom: 0;
    }
    .control-group > label:first-child {
      font-weight: bold; display: block; margin-bottom: 5px;
    }
    #controls label, #controls button, #controls input[type="number"] {
      display: inline-block; margin: 5px 8px 5px 0; vertical-align: middle;
    }
    #controls input[type="number"] {
      width: 65px; padding: 4px 6px; border: 1px solid #ccc; border-radius: 3px; margin-left: 2px;
    }
    .my-svg-layer { pointer-events: none; }
    .my-svg-layer svg {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: auto; user-select: none;
      overflow: visible; cursor: grab;
    }
    .my-svg-layer svg:active { cursor: grabbing; }
    #svg-content-group {}
  </style>
</head>
<body>

  <div id="map"></div>

  <div id="controls">
    <div class="control-group">
      <label>1. Position Map & Place SVG:</label>
      <button id="btnPlaceSVG" disabled>Place SVG Here</button>
      <span id="svgStatus" style="font-style: italic; color: #555;">(Loading SVG...)</span>
    </div>

    <div class="control-group">
      <label>2. Point Spacing:</label>
      <div>
        <label for="singleDist">Distance (m):</label>
        <input type="number" id="singleDist" value="1" min="0.1" step="0.1" disabled>
      </div>
    </div>

    <div class="control-group">
      <label>3. Generate & Export:</label>
      <button id="btnGeneratePoints" disabled>Generate Points on SVG</button>
      <button id="btnExportKML" disabled>Export KML</button>
    </div>

    <div class="control-group">
      <label>4. Adjust SVG:</label>
      <button id="btnRotateLeft" disabled>Rotate Left (-10°)</button>
      <button id="btnRotateRight" disabled>Rotate Right (+10°)</button>
      <button id="btnScaleUp" disabled>Scale Up (x1.1)</button>
      <button id="btnScaleDown" disabled>Scale Down (x0.9)</button>
    </div>
  </div>

  <!-- Dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.1.2/dist/svg.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.draggable.js@3.0.2/dist/svg.draggable.min.js"></script>
  <script src="./js/libs/svg-path-properties.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tokml@0.4.0/tokml.min.js"></script>

  <script>
  "use strict";

  // --- Configuration ---
  const SVG_PATH_TO_LOAD       = './svg/11-52.svg';
  const POINT_MARKER_OPTIONS   = { radius: 3, color: 'red', fillColor: '#f03', fillOpacity: 0.8, weight: 1 };
  const MAX_POINTS_PER_PATH    = 20000;

  let map, svgLayer, svgRoot, svgGroup;
  let userPathElements = [], generatedPoints = [], pointMarkers = [];
  let localSVGWidth = 300, localSVGHeight = 300;
  let currentRotation = 0, currentScale = 1;
  let SvgPathPropertiesConstructor = null;

  // Deferred‐placement flags
  let loadedSvgText = null, isSvgDataLoaded = false;

  // 1️⃣ Dependency check
  function checkDependencies() {
    let ok = true;
    if (typeof L === 'undefined')    { alert("Leaflet (L) missing!"); ok = false; }
    if (typeof SVG === 'undefined')  { alert("svg.js (SVG) missing!"); ok = false; }
    if (SVG.extend && SVG.Element && !SVG.Element.prototype.draggable) {
      alert("svg.draggable.js missing!"); ok = false;
    }
    if (typeof svgPathProperties === 'undefined') {
      alert("svg-path-properties missing!"); ok = false;
    } else {
      SvgPathPropertiesConstructor = typeof svgPathProperties === 'function'
        ? svgPathProperties
        : (svgPathProperties.svgPathProperties || svgPathProperties.default);
      if (typeof SvgPathPropertiesConstructor !== 'function') {
        console.error("Bad svg-path-properties export:", svgPathProperties);
        ok = false;
      }
    }
    if (typeof tokml === 'undefined') { alert("tokml missing!"); ok = false; }
    return ok;
  }

  // 2️⃣ Custom SVG overlay layer
  const CustomSvgLayer = L.Layer.extend({
    initialize(svgEl, bounds, opts) {
      this._svgElement = svgEl;
      this._bounds     = L.latLngBounds(bounds);
      L.setOptions(this, opts);
    },
    onAdd(map) {
      this._map = map;
      if (!this._container) {
        this._container = L.DomUtil.create('div','my-svg-layer leaflet-zoom-animated');
        this._container.appendChild(this._svgElement);
      }
      map.getPanes().overlayPane.appendChild(this._container);
      this._update();
      map.on('zoomend viewreset moveend', this._update, this);
    },
    onRemove(map) {
      if (this._container) map.getPanes().overlayPane.removeChild(this._container);
      map.off('zoomend viewreset moveend', this._update, this);
      this._container = null; this._map = null;
    },
    _update() {
      if (!this._map || !this._bounds || !this._container) return;
      const tl = this._map.latLngToLayerPoint(this._bounds.getNorthWest());
      const br = this._map.latLngToLayerPoint(this._bounds.getSouthEast());
      const w = Math.max(0, br.x - tl.x), h = Math.max(0, br.y - tl.y);
      L.DomUtil.setPosition(this._container, tl);
      this._container.style.width  = w + 'px';
      this._container.style.height = h + 'px';
    },
    setBounds(b) {
      this._bounds = L.latLngBounds(b);
      if (this._map) this._update();
      return this;
    },
    getBounds() { return this._bounds; }
  });
  L.customSvgLayer = (svgEl, bounds, opts) => new CustomSvgLayer(svgEl, bounds, opts);

  // 3️⃣ Initialize map & UI
  function initMap() {
    map = L.map('map').setView([0,0],2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
      maxZoom:19, attribution:'© OSM contributors'
    }).addTo(map);
    L.control.scale({ imperial:false }).addTo(map);
  }

  function updateUI() {
    const placed = !!svgLayer;
    const hasPts = generatedPoints.length>0;

    document.getElementById('btnPlaceSVG').disabled    = !isSvgDataLoaded || placed;
    document.getElementById('svgStatus').textContent   = isSvgDataLoaded
      ? (placed? " (SVG Placed)" : " (SVG Ready – Navigate & Place)")
      : " (Loading SVG...)";

    document.getElementById('singleDist').disabled     = !placed;
    document.getElementById('btnGeneratePoints').disabled = !placed;
    document.getElementById('btnExportKML').disabled  = !placed || !hasPts;
    ['btnRotateLeft','btnRotateRight','btnScaleUp','btnScaleDown']
      .forEach(id=>document.getElementById(id).disabled = !placed);
  }

  // 4️⃣ Load & process SVG (deferred placement)
  function processLoadedSVGData(svgText) {
    try {
      const parser = new DOMParser(),
            doc    = parser.parseFromString(svgText,'image/svg+xml'),
            err    = doc.querySelector('parsererror');
      if (err) throw new Error(err.textContent);

      const root = doc.documentElement;
      if (!root || root.tagName.toLowerCase()!=='svg') {
        throw new Error("No <svg> root");
      }

      // determine dimensions
      let [w,h]=[0,0];
      const vb = root.getAttribute('viewBox');
      if (vb) {
        const parts = vb.split(/[\s,]+/).map(Number);
        if (parts.length===4) [w,h] = [parts[2],parts[3]];
      }
      if (!w||!h) {
        w = parseFloat(root.getAttribute('width'))  || 300;
        h = parseFloat(root.getAttribute('height')) || 300;
      }
      localSVGWidth = w>0? w:300;
      localSVGHeight= h>0? h:300;

      loadedSvgText   = svgText;
      isSvgDataLoaded = true;
    } catch (e) {
      console.error("SVG processing failed:",e);
      alert("Failed to process SVG: "+e.message);
      isSvgDataLoaded = false;
      loadedSvgText   = null;
    } finally {
      updateUI();
    }
  }

  async function loadAndProcessSVG(path) {
    isSvgDataLoaded = false; loadedSvgText = null;
    updateUI();
    try {
      const res = await fetch(path);
      if (!res.ok) throw new Error("HTTP "+res.status);
      const txt = await res.text();
      processLoadedSVGData(txt);
    } catch (e) {
      console.error("SVG load error:",e);
      alert("Failed to load SVG: "+e.message);
      document.getElementById('svgStatus').textContent = " (Error Loading SVG)";
      updateUI();
    }
  }
  // 5️⃣ SVG Transformations
  function applyTransform() {
    if (!svgGroup) return;
    svgGroup.transform({
      rotate: currentRotation,
      scale:  currentScale,
      origin: [localSVGWidth/2, localSVGHeight/2]
    });
    if (generatedPoints.length) drawGeneratedPoints();
  }
  function rotateSVG(deg) {
    if (!svgLayer) return;
    currentRotation += deg;
    applyTransform();
  }
  function scaleSVG(f) {
    if (!svgLayer) return;
    currentScale *= f;
    applyTransform();
  }

  // 6️⃣ Calculate spacing in SVG units
  function getDistanceParams() {
    if (!svgLayer||!map||!svgRoot||!svgGroup) return null;
    let mpsu;
    try {
      const p1 = {x:0,y:localSVGHeight/2},
            p2 = {x:localSVGWidth,y:localSVGHeight/2};
      const ll1 = _getTransformedLatLng(p1),
            ll2 = _getTransformedLatLng(p2);
      const md = map.distance(ll1,ll2);
      mpsu = md/localSVGWidth;
      if (!isFinite(mpsu)||mpsu<=0) throw new Error("Bad scale");
    } catch (e) {
      console.error("Scale error:",e);
      alert("Scale calc failed: "+e.message);
      return null;
    }
    const meters = parseFloat(document.getElementById('singleDist').value);
    if (!(meters>0)) {
      alert("Enter a positive distance.");
      return null;
    }
    return { mode:'single', options:{ singleDist: Math.max(1e-6, meters/mpsu) } };
  }

  // 7️⃣ Extract path data & generate points
  function _getPathDataFromElement(el) {
    if (!el) return null;
    const tag = el.tagName.toLowerCase(), attrs = el.attributes;
    let d = '';
    try {
      switch(tag) {
        case 'path':
          d = el.getAttribute('d')||''; break;
        case 'line':
          const x1=+el.getAttribute('x1'),y1=+el.getAttribute('y1'),
                x2=+el.getAttribute('x2'),y2=+el.getAttribute('y2');
          if ([x1,y1,x2,y2].some(isNaN)) throw "Invalid line coords";
          d = `M ${x1} ${y1} L ${x2} ${y2}`; break;
        case 'polyline':
        case 'polygon':
          const pts = (el.getAttribute('points')||'').trim().split(/[\s,]+/).map(Number);
          if (pts.length<4||pts.some(isNaN)) throw "Bad points";
          d = `M ${pts[0]} ${pts[1]}` +
              pts.slice(2).reduce((str,v,i)=>i%2? str+` L ${v}`:str+` ${v}`, '');
          if (tag==='polygon') d += ' Z';
          break;
        case 'rect':
          const x=+el.getAttribute('x')||0,y=+el.getAttribute('y')||0,
                w=+el.getAttribute('width'),h=+el.getAttribute('height');
          if ([w,h].some(v=>isNaN(v)||v<=0)) throw "Bad rect";
          d = `M ${x} ${y} H ${x+w} V ${y+h} H ${x} Z`; break;
        case 'circle':
          const cx=+el.getAttribute('cx'),cy=+el.getAttribute('cy'),
                r=+el.getAttribute('r');
          if ([cx,cy,r].some(v=>isNaN(v)||r<=0)) throw "Bad circle";
          d = `M ${cx-r} ${cy}` +
              `A ${r},${r} 0 1,0 ${cx+r},${cy}` +
              `A ${r},${r} 0 1,0 ${cx-r},${cy} Z`; break;
        case 'ellipse':
          const ecx=+el.getAttribute('cx'),ecy=+el.getAttribute('cy'),
                rx=+el.getAttribute('rx'),ry=+el.getAttribute('ry');
          if ([ecx,ecy,rx,ry].some(v=>isNaN(v)||rx<=0||ry<=0)) throw "Bad ellipse";
          d = `M ${ecx-rx} ${ecy}` +
              `A ${rx},${ry} 0 1,0 ${ecx+rx},${ecy}` +
              `A ${rx},${ry} 0 1,0 ${ecx-rx},${ecy} Z`; break;
        default:
          return null;
      }
      return d.trim()||null;
    } catch(e) {
      console.warn(`Skip ${tag}:`,e);
      return null;
    }
  }

  function _generatePointsForPath(dAttr, mode, opts, props) {
    const pts = [];
    try {
      const prop = new SvgPathPropertiesConstructor(dAttr),
            len  = prop.getTotalLength();
      if (len<1e-6) {
        const p0=prop.getPointAtLength(0);
        if(p0) pts.push({...p0,...props});
        return pts;
      }
      let dist=0;
      pts.push({...prop.getPointAtLength(0),...props});
      while(dist<len) {
        dist += Math.max(1e-6, opts.singleDist);
        if(dist<len) {
          const p=prop.getPointAtLength(dist);
          if(p) pts.push({...p,...props});
        }
        if(pts.length>=MAX_POINTS_PER_PATH) break;
      }
      const end=prop.getPointAtLength(len),
            last=pts[pts.length-1];
      if(end && Math.hypot(end.x-last.x,end.y-last.y)>1e-5) {
        pts.push({...end,...props});
      }
    } catch(e) {
      console.error(`Point gen error for ${props.sourceId}:`,e);
    }
    return pts;
  }

  function generatePoints() {
    if(!svgLayer||!svgRoot||!userPathElements.length) {
      return alert("SVG not placed or no vector elements.");
    }
    const p = getDistanceParams();
    if(!p) return;

    generatedPoints=[];
    pointMarkers.forEach(m=>map.removeLayer(m));
    pointMarkers=[];

    let total=0, proc=0, skip=0;
    userPathElements.forEach((el,i)=>{
      const id = el.id||`idx${i}`, tag=el.tagName.toLowerCase();
      const d  = _getPathDataFromElement(el);
      if(!d){ skip++; return; }
      proc++;
      const newPts = _generatePointsForPath(d,p.mode,p.options,{
        sourceIndex:i, sourceId:id, sourceTag:tag
      });
      if(newPts.length){
        generatedPoints.push(...newPts);
        total+=newPts.length;
      }
    });

    if(total>0){
      drawGeneratedPoints();
      alert(`Generated ${total} points from ${proc} elements (${skip} skipped).`);
    } else {
      alert(`No points generated. Processed ${proc}, skipped ${skip}.`);
    }
    updateUI();
  }
  // 8️⃣ Place SVG on the map
  function placeSVGOnMap() {
    if(!isSvgDataLoaded||!loadedSvgText){
      return alert("SVG data not ready.");
    }
    if(svgLayer){ map.removeLayer(svgLayer); svgLayer=null; }
    if(svgRoot){ svgRoot=null; svgGroup=null; }

    userPathElements=[]; generatedPoints=[]; pointMarkers.forEach(m=>map.removeLayer(m)); pointMarkers=[];
    currentRotation=0; currentScale=1;

    let parsedSVG;
    try {
      const doc = new DOMParser().parseFromString(loadedSvgText,"image/svg+xml");
      parsedSVG = doc.documentElement;
    } catch(e){
      return alert("Re-parse error: "+e.message);
    }

    parsedSVG.setAttribute('viewBox', `0 0 ${localSVGWidth} ${localSVGHeight}`);
    parsedSVG.setAttribute('width','100%');
    parsedSVG.setAttribute('height','100%');
    parsedSVG.setAttribute('preserveAspectRatio','xMidYMid meet');
    parsedSVG.style.overflow = 'visible';

    const center  = map.getCenter(),
          zoom    = map.getZoom(),
          size    = map.getSize(),
          pxW     = Math.min(size.x*0.6, size.y*0.6*(localSVGWidth/localSVGHeight),600),
          pxH     = pxW*(localSVGHeight/localSVGWidth),
          cPx     = map.project(center,zoom),
          nwPx    = cPx.subtract([pxW/2,pxH/2]),
          sePx    = cPx.add    ([pxW/2,pxH/2]),
          bounds  = L.latLngBounds(
            map.unproject(nwPx,zoom),
            map.unproject(sePx,zoom)
          );

    svgLayer = L.customSvgLayer(parsedSVG,bounds).addTo(map);

    svgRoot  = SVG(parsedSVG);
    svgGroup = svgRoot.group().id('svg-content-group');

    Array.from(parsedSVG.childNodes).forEach(node=>{
      if(node.nodeType===1 &&
         node!==svgGroup.node &&
         !['defs','style','metadata','title','desc','script']
           .includes(node.nodeName.toLowerCase())
      ){
        try{ svgGroup.add(SVG(node)); }
        catch(e){ console.warn("move failed:",e); }
      }
    });

    applyTransform();

    if(svgGroup.draggable){
      svgGroup.draggable()
        .on('dragstart',e=>{
          map.dragging.disable();
          e.detail.handler.el.remember('_sb',svgLayer.getBounds());
        })
        .on('dragmove',e=>{
          const sb = e.detail.handler.el.remember('_sb');
          if(!sb) return;
          const {x:dx,y:dy} = e.detail.delta;
          const p1 = map.latLngToLayerPoint(sb.getNorthWest()),
                p2 = map.latLngToLayerPoint(sb.getSouthEast());
          const p1n= p1.add([dx,dy]), p2n= p2.add([dx,dy]);
          const nb = L.latLngBounds(
            map.layerPointToLatLng(p1n),
            map.layerPointToLatLng(p2n)
          );
          svgLayer.setBounds(nb);
          if(generatedPoints.length) drawGeneratedPoints();
        })
        .on('dragend',e=>{
          map.dragging.enable();
          e.detail.handler.el.forget('_sb');
          if(generatedPoints.length) drawGeneratedPoints();
        });
    }

    userPathElements = Array.from(parsedSVG.querySelectorAll('path,line,polyline,polygon,rect,circle,ellipse'));
    if(!userPathElements.length){
      alert("Warning: No vector shapes found.");
    }
    updateUI();
  }

  // 9️⃣ Draw point markers
  function _getTransformedLatLng(pt) {
    if(!svgRoot||!svgGroup||!map) return null;
    const ctm = svgGroup.node.getScreenCTM();
    if(!ctm) return null;
    const svgP = svgRoot.node.createSVGPoint();
    svgP.x=pt.x; svgP.y=pt.y;
    const tr = svgP.matrixTransform(ctm);
    const rect = map.getContainer().getBoundingClientRect();
    return map.containerPointToLatLng([tr.x-rect.left, tr.y-rect.top]);
  }

  function drawGeneratedPoints() {
    pointMarkers.forEach(m=>map.removeLayer(m));
    pointMarkers = [];
    let fail=0;
    generatedPoints.forEach((pt,i)=>{
      const ll = _getTransformedLatLng(pt);
      if(ll){
        const mk = L.circleMarker(ll,POINT_MARKER_OPTIONS)
          .bindTooltip(`Point ${i+1}<br>Source: ${pt.sourceTag} ${pt.sourceId}`);
        mk.addTo(map);
        pointMarkers.push(mk);
      } else fail++;
    });
    if(fail) console.warn(`Failed to draw ${fail} points.`);
  }

  // 🔟 Build GeoJSON + KML export
  function buildDataForKML() {
    if(!generatedPoints.length) return null;
    const feats = generatedPoints.map((pt,i)=>{
      const ll = _getTransformedLatLng(pt);
      return {
        name: (i+1).toString(),
        description: `Source: ${pt.sourceTag} ${pt.sourceId} (SVG x=${pt.x.toFixed(2)},y=${pt.y.toFixed(2)})`,
        geometry: { type:"Point", coordinates:[ll.lng,ll.lat] }
      };
    });
    return { type:"FeatureCollection", features:feats };
  }

  function exportKML() {
  // 1) Get the GeoJSON
  const data = buildDataForKML();
  if (!data || !data.features.length) {
    return alert("No point data to export.");
  }

  // 2) Convert to KML
  const kmlString = tokml(data, {
    name:        'name',
    description: 'description'
  });

  // 3) Download
  const blob = new Blob([kmlString], {
    type: "application/vnd.google-earth.kml+xml"
  });
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement("a");
  a.href     = url;
  a.download = "svg_points.kml";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);

  console.log("KML export complete.");
}


  // Init everything
  document.addEventListener('DOMContentLoaded',()=>{
    if(!checkDependencies()){
      alert("Dependencies missing; check console.");
      return;
    }
    initMap();
    loadAndProcessSVG(SVG_PATH_TO_LOAD);
    document.getElementById('btnPlaceSVG').addEventListener('click', placeSVGOnMap);
    document.getElementById('btnGeneratePoints').addEventListener('click', generatePoints);
    document.getElementById('btnExportKML').addEventListener('click', exportKML);
    document.getElementById('btnRotateLeft').addEventListener('click', ()=>rotateSVG(-10));
    document.getElementById('btnRotateRight').addEventListener('click', ()=>rotateSVG(10));
    document.getElementById('btnScaleUp').addEventListener('click', ()=>scaleSVG(1.1));
    document.getElementById('btnScaleDown').addEventListener('click', ()=>scaleSVG(0.9));
    updateUI();
  });
  </script>
</body>
</html>
