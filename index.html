<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SVG Overlay Point Generator - KML Export</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      font-family: Arial, sans-serif;
      overflow: hidden;
      display: flex; flex-direction: column;
    }
    #map {
      width: 100%; flex-grow: 1; min-height: 200px;
      position: relative;
    }
    #controls {
      padding: 12px; background: #f4f4f4; border-top: 1px solid #ccc;
      overflow-y: auto; max-height: 40%;
      flex-shrink: 0;
    }
    .control-group {
      margin-bottom: 10px; padding-bottom: 10px;
      border-bottom: 1px dashed #ddd;
    }
    .control-group:last-child {
      border-bottom: none; margin-bottom: 0; padding-bottom: 0;
    }
    .control-group > label:first-child {
      font-weight: bold; display: block; margin-bottom: 5px;
    }
    #controls label, #controls button, #controls input[type="number"] {
      display: inline-block; margin: 5px 8px 5px 0; vertical-align: middle;
    }
    #controls input[type="number"] {
      width: 65px; padding: 4px 6px; border: 1px solid #ccc; border-radius: 3px; margin-left: 2px;
    }
    .my-svg-layer { pointer-events: none; }
    .my-svg-layer svg {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: auto; user-select: none;
      overflow: visible; cursor: grab;
    }
    .my-svg-layer svg:active { cursor: grabbing; }
    #svg-content-group {}
  </style>
</head>
<body>

  <div id="map"></div>

  <div id="controls">
    <div class="control-group">
      <label>1. Position Map & Place SVG:</label> <!-- Renumbered -->
      <button id="btnPlaceSVG" disabled>Place SVG Here</button>
      <span id="svgStatus" style="font-style: italic; color: #555;"> (Loading SVG...)</span>
    </div>

    <div class="control-group">
      <label>2. Point Spacing:</label> <!-- Renumbered -->
      <div>
        <label for="singleDist">Distance (m):</label>
        <input type="number" id="singleDist" value="1" min="0.1" step="0.1" disabled> <!-- Disabled initially -->
      </div>
    </div>

    <div class="control-group">
      <label>3. Generate & Export:</label> <!-- Renumbered -->
      <button id="btnGeneratePoints" disabled>Generate Points on SVG</button>
      <button id="btnExportKML" disabled>Export KML</button>
    </div>

    <div class="control-group">
      <label>4. Adjust SVG:</label> <!-- Renumbered -->
      <button id="btnRotateLeft" disabled>Rotate Left (-10°)</button>
      <button id="btnRotateRight" disabled>Rotate Right (+10°)</button>
      <button id="btnScaleUp" disabled>Scale Up (x1.1)</button>
      <button id="btnScaleDown" disabled>Scale Down (x0.9)</button>
    </div>
  </div>

  <!-- Dependencies (remain the same) -->
  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.1.2/dist/svg.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.draggable.js@3.0.2/dist/svg.draggable.min.js"></script>
  <script src="./js/libs/svg-path-properties.js"></script> <!-- Ensure path -->
  <script src="https://cdn.jsdelivr.net/npm/tokml@0.4.0/tokml.min.js"></script>
  
    <script> // <-- START OF SINGLE SCRIPT BLOCK
  "use strict";

  // --- Configuration ---
  const SVG_PATH_TO_LOAD = './svg/11-52.svg'; // Path to your SVG file

  // Globals & constants
  const POINT_MARKER_OPTIONS = { radius: 3, color: 'red', fillColor: '#f03', fillOpacity: 0.8, weight: 1 };
  const MAX_POINTS_PER_PATH = 20000;

  let map, svgLayer, svgRoot, svgGroup;
  let userPathElements = [], generatedPoints = [], pointMarkers = [];
  let localSVGWidth = 300, localSVGHeight = 300;
  let currentRotation = 0, currentScale = 1;
  let SvgPathPropertiesConstructor = null;

  // --- NEW Globals for deferred placement ---
  let loadedSvgText = null;     // To store the fetched SVG text
  let isSvgDataLoaded = false; // Flag to indicate if SVG data is ready

  // 1️⃣ Dependency check (no changes)
  function checkDependencies() {
    let ok = true;
    if (typeof L === 'undefined') { alert("Leaflet library (L) is missing!"); ok = false; }
    if (typeof SVG === 'undefined') { alert("svg.js library (SVG) is missing!"); ok = false; }
    if (typeof SVG.extend === 'function' && typeof SVG.Element !== 'undefined' && typeof SVG.Element.prototype.draggable !== 'function') {
         alert("svg.draggable.js extension missing!");
    }
    if (typeof svgPathProperties === 'undefined') {
      alert("svg-path-properties library is missing!"); ok = false;
    } else {
      SvgPathPropertiesConstructor = typeof svgPathProperties === 'function' ? svgPathProperties : (svgPathProperties.svgPathProperties || svgPathProperties.default);
      if (typeof SvgPathPropertiesConstructor !== 'function') {
        console.error("svg-path-properties constructor not found:", svgPathProperties); ok = false;
      }
    }
     if (typeof tokml === 'undefined') { alert("tokml library is missing!"); ok = false; }
    return ok;
  }

  // 2️⃣ Custom SVG overlay Layer for Leaflet (no changes)
  const CustomSvgLayer = L.Layer.extend({
    initialize: function(svgElement, bounds, options) { /* ... */ },
    onAdd: function(map) { /* ... */ },
    onRemove: function(map) { /* ... */ },
    _update: function() { /* ... */ },
    setBounds: function(bounds) { /* ... */ },
    getBounds: function() { /* ... */ }
  });
  // Explicitly copy implementation from previous working version
  CustomSvgLayer.prototype.initialize = function(svgElement, bounds, options) {
      this._svgElement = svgElement; this._bounds = L.latLngBounds(bounds); L.setOptions(this, options);
  };
  CustomSvgLayer.prototype.onAdd = function(map) {
      this._map = map; if (!this._container) { this._container = L.DomUtil.create('div', 'my-svg-layer leaflet-zoom-animated'); this._container.appendChild(this._svgElement); } map.getPanes().overlayPane.appendChild(this._container); this._update(); map.on('zoomend viewreset moveend', this._update, this);
  };
  CustomSvgLayer.prototype.onRemove = function(map) {
      if (this._container) { map.getPanes().overlayPane.removeChild(this._container); } map.off('zoomend viewreset moveend', this._update, this); this._container = null; this._map = null;
  };
  CustomSvgLayer.prototype._update = function() {
      if (!this._map || !this._bounds || !this._container) { return; } const topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()); const bottomRight = this._map.latLngToLayerPoint(this._bounds.getSouthEast()); const width = Math.max(0, bottomRight.x - topLeft.x); const height = Math.max(0, bottomRight.y - topLeft.y); L.DomUtil.setPosition(this._container, topLeft); this._container.style.width = width + 'px'; this._container.style.height = height + 'px';
  };
  CustomSvgLayer.prototype.setBounds = function(bounds) {
      this._bounds = L.latLngBounds(bounds); if (this._map) { this._update(); } return this;
  };
  CustomSvgLayer.prototype.getBounds = function() { return this._bounds; };
  // End explicit copy

  L.customSvgLayer = function(svgElement, bounds, options) {
    return new CustomSvgLayer(svgElement, bounds, options);
  };

  // 3️⃣ Initialize map & UI
  function initMap() {
    map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© OSM contributors' }).addTo(map);
    L.control.scale({ imperial: false }).addTo(map);
  }

  // MODIFIED updateUI for new state management
  function updateUI() {
    const svgPlaced = !!svgLayer; // Check if the layer exists on the map
    const hasGeneratedPoints = generatedPoints.length > 0;

    // Place button enabled only when data loaded but not yet placed
    document.getElementById('btnPlaceSVG').disabled = !isSvgDataLoaded || svgPlaced;
    document.getElementById('svgStatus').textContent = isSvgDataLoaded
        ? (svgPlaced ? " (SVG Placed)" : " (SVG Ready - Navigate and Place)")
        : " (Loading SVG...)";


    // Other controls enabled only after SVG is placed
    document.getElementById('singleDist').disabled = !svgPlaced;
    document.getElementById('btnGeneratePoints').disabled = !svgPlaced;
    document.getElementById('btnExportKML').disabled = !svgPlaced || !hasGeneratedPoints;
    ['btnRotateLeft', 'btnRotateRight', 'btnScaleUp', 'btnScaleDown']
      .forEach(id => document.getElementById(id).disabled = !svgPlaced);
  }

  // 4️⃣ SVG Loading and Processing (Split)

  // NEW function: Processes the loaded SVG text - DOES NOT place it
  function processLoadedSVGData(svgText) {
     console.log("Processing loaded SVG data...");
     try {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svgText, "image/svg+xml");
        const parserError = doc.querySelector('parsererror');
        if (parserError) { throw new Error("Invalid SVG structure: " + parserError.textContent); }
        const parsedSVG = doc.documentElement;
        if (!parsedSVG || parsedSVG.tagName.toLowerCase() !== 'svg') { throw new Error("Not a valid <svg> root element."); }

        // Get dimensions
        let viewBox = parsedSVG.getAttribute('viewBox');
        let tempWidth = 0, tempHeight = 0;
        if (viewBox) {
            const parts = viewBox.split(/[\s,]+/);
            if (parts.length === 4) { tempWidth = parseFloat(parts[2]); tempHeight = parseFloat(parts[3]); }
        }
        if (isNaN(tempWidth) || tempWidth <= 0 || isNaN(tempHeight) || tempHeight <= 0) {
            tempWidth = parseFloat(parsedSVG.getAttribute('width')) || 300;
            tempHeight = parseFloat(parsedSVG.getAttribute('height')) || 300;
            if (tempWidth <= 0) tempWidth = 300; if (tempHeight <= 0) tempHeight = 300;
        }
        // Store dimensions globally
        localSVGWidth = tempWidth;
        localSVGHeight = tempHeight;
        console.log(`Stored SVG dimensions: ${localSVGWidth}x${localSVGHeight}`);

        // Store the raw text for later use when placing
        loadedSvgText = svgText;
        isSvgDataLoaded = true;
        console.log("SVG data processed and ready.");

     } catch (error) {
         console.error("Error processing SVG data:", error);
         alert(`Failed to process SVG data: ${error.message}`);
         isSvgDataLoaded = false;
         loadedSvgText = null;
     } finally {
         // Update UI regardless of success/failure to process
         updateUI();
     }
  }


  // MODIFIED: Loads SVG but calls processor instead of placer
  async function loadAndProcessSVG(svgPath) {
    isSvgDataLoaded = false; // Reset flag
    loadedSvgText = null;
    updateUI(); // Show "Loading..."
    try {
        console.log(`Attempting to load SVG from: ${svgPath}`);
        const response = await fetch(svgPath);
        console.log(`Fetch response status for ${svgPath}: ${response.status}`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const svgText = await response.text();
        console.log(`Successfully fetched SVG text from ${svgPath}.`);
        // Process the loaded text (stores dimensions and text)
        processLoadedSVGData(svgText);
    } catch (error) {
        console.error(`Error loading SVG from path "${svgPath}":`, error);
        alert(`Failed to load SVG from ${svgPath}. Check path and file.\nError: ${error.message}`);
        document.getElementById('svgStatus').textContent = " (Error Loading SVG)";
        updateUI(); // Update UI to reflect failure
    }
  }

  // 5️⃣ SVG Transformations (Rotate/Scale) - (no changes)
  function applyTransform() { /* ... */ }
  function rotateSVG(degrees) { /* ... */ }
  function scaleSVG(factor) { /* ... */ }
  // Explicitly copy implementation from previous working version
  applyTransform = function() {
    if (!svgGroup) { return; }
    svgGroup.transform({ rotate: currentRotation, scale: currentScale, origin: [localSVGWidth / 2, localSVGHeight / 2] });
    if (pointMarkers.length > 0 || generatedPoints.length > 0) { drawGeneratedPoints(); }
  };
  rotateSVG = function(degrees) {
    if (!svgLayer) return; currentRotation += degrees; applyTransform();
  };
  scaleSVG = function(factor) {
    if (!svgLayer) return; currentScale *= factor; applyTransform();
  };
  // End explicit copy

  // 6️⃣ Get Distance Parameters (no changes needed, reads from UI when called)
  function getDistanceParams() { /* ... */ }
   // Explicitly copy implementation from previous working version
   getDistanceParams = function() {
    if (!svgLayer || !map || !svgRoot || !svgGroup || localSVGWidth <= 0) { console.error("Cannot calc distance: Missing components."); return null; }
    const mode = 'single'; let metersPerSvgUnit;
    try {
        const point1_svg = { x: 0, y: localSVGHeight / 2 }; const point2_svg = { x: localSVGWidth, y: localSVGHeight / 2 };
        const point1_ll = _getTransformedLatLng(point1_svg); const point2_ll = _getTransformedLatLng(point2_svg);
        if (!point1_ll || !point2_ll) { throw new Error("Failed to transform ref points."); }
        const mapDistanceMeters = map.distance(point1_ll, point2_ll); const svgDistance = localSVGWidth;
        if (mapDistanceMeters <= 0 || svgDistance <= 0) { throw new Error(`Invalid distances: Map=${mapDistanceMeters}m, SVG=${svgDistance}u`); }
        metersPerSvgUnit = mapDistanceMeters / svgDistance; console.log(`Scale: ${metersPerSvgUnit.toFixed(4)} m/SVG unit`);
    } catch (error) { console.error("Scale calculation error:", error); alert(`Scale error: ${error.message}.`); return null; }
    if (!metersPerSvgUnit || metersPerSvgUnit <= 0 || !isFinite(metersPerSvgUnit)) { console.error("Invalid m/SVG unit:", metersPerSvgUnit); alert("Scale calc invalid."); return null; }
    let options = {};
    try {
        const singleMeters = parseFloat(document.getElementById('singleDist').value);
        if (!(singleMeters > 0)) { throw new Error("Invalid distance > 0."); }
        options.singleDist = singleMeters / metersPerSvgUnit; if (options.singleDist < 1e-6) options.singleDist = 1e-6;
    } catch (error) { alert(`Input Error: ${error.message}`); return null; }
    return { mode: mode, options: options };
  };
   // End explicit copy


  // 7️⃣ Point Generation Logic (_getPathDataFromElement, _generatePointsForPath, generatePoints - no changes needed)
  function _getPathDataFromElement(el) { /* ... */ }
  function _generatePointsForPath(dAttribute, mode, distanceOptions, pathProperties) { /* ... */ }
  function generatePoints() { /* ... */ }
   // Explicitly copy implementation from previous working version
   _getPathDataFromElement = function(el) {
    if (!el) return null; const tag = el.tagName.toLowerCase(); let d = ''; try { switch (tag) { case 'path': d = el.getAttribute('d') || ''; break; case 'line': const x1=parseFloat(el.getAttribute('x1')), y1=parseFloat(el.getAttribute('y1')), x2=parseFloat(el.getAttribute('x2')), y2=parseFloat(el.getAttribute('y2')); if ([x1,y1,x2,y2].some(isNaN)) throw new Error("Invalid line coords"); d = `M ${x1} ${y1} L ${x2} ${y2}`; break; case 'polyline': case 'polygon': const pointsStr = el.getAttribute('points')?.trim(); if (!pointsStr) throw new Error("No points attr"); const points = pointsStr.split(/[\s,]+/); if (points.length < 2 || points.length % 2 !== 0) throw new Error("Invalid points number"); const coords = points.map(p => parseFloat(p)); if (coords.some(isNaN)) throw new Error("Invalid coord value"); d = `M ${coords[0]} ${coords[1]}`; for (let i=2; i < coords.length; i+=2) { d += ` L ${coords[i]} ${coords[i+1]}`; } if (tag === 'polygon') d += ' Z'; break; case 'rect': const x=parseFloat(el.getAttribute('x')||'0'), y=parseFloat(el.getAttribute('y')||'0'), width=parseFloat(el.getAttribute('width')), height=parseFloat(el.getAttribute('height')); if (isNaN(x)||isNaN(y)||isNaN(width)||isNaN(height)||width<=0||height<=0) throw new Error("Invalid rect attrs"); d = `M ${x} ${y} H ${x+width} V ${y+height} H ${x} Z`; break; case 'circle': const cx=parseFloat(el.getAttribute('cx')), cy=parseFloat(el.getAttribute('cy')), r=parseFloat(el.getAttribute('r')); if(isNaN(cx)||isNaN(cy)||isNaN(r)||r<=0) throw new Error("Invalid circle attrs"); d = `M ${cx-r} ${cy} A ${r},${r} 0 1,0 ${cx+r},${cy} A ${r},${r} 0 1,0 ${cx-r},${cy} Z`; break; case 'ellipse': const ecx=parseFloat(el.getAttribute('cx')), ecy=parseFloat(el.getAttribute('cy')), rx=parseFloat(el.getAttribute('rx')), ry=parseFloat(el.getAttribute('ry')); if(isNaN(ecx)||isNaN(ecy)||isNaN(rx)||isNaN(ry)||rx<=0||ry<=0) throw new Error("Invalid ellipse attrs"); d = `M ${ecx-rx},${ecy} A ${rx},${ry} 0 1,0 ${ecx+rx},${ecy} A ${rx},${ry} 0 1,0 ${ecx-rx},${ecy} Z`; break; default: return null; } if (!d.trim()) return null; return d; } catch (error) { console.warn(`Skip element ${el.id||tag}: ${error.message}`); return null; }
   };
   _generatePointsForPath = function(dAttribute, mode, distanceOptions, pathProperties) {
    const points = []; if (!dAttribute || typeof dAttribute !== 'string' || !dAttribute.trim()) { return points; } try { const properties = new SvgPathPropertiesConstructor(dAttribute); const totalLength = properties.getTotalLength(); if (totalLength < 1e-6) { const startPoint = properties.getPointAtLength(0); if (startPoint && typeof startPoint.x === 'number') { points.push({ ...startPoint, ...pathProperties }); } return points; } let currentDist = 0; points.push({ ...properties.getPointAtLength(0), ...pathProperties }); while (currentDist < totalLength) { const step = Math.max(1e-6, distanceOptions.singleDist); currentDist += step; if (currentDist < totalLength) { const nextPoint = properties.getPointAtLength(currentDist); if (nextPoint && typeof nextPoint.x === 'number') { points.push({ ...nextPoint, ...pathProperties }); } } if (points.length >= MAX_POINTS_PER_PATH) { console.warn(`Max points for ${pathProperties.sourceId}`); break; } } const endPoint = properties.getPointAtLength(totalLength); if (endPoint && typeof endPoint.x === 'number') { const lastGeneratedPoint = points[points.length - 1]; if (!lastGeneratedPoint || Math.hypot(endPoint.x - lastGeneratedPoint.x, endPoint.y - lastGeneratedPoint.y) > 1e-5) { points.push({ ...endPoint, ...pathProperties }); } } } catch (error) { console.error(`Error gen points for ${pathProperties.sourceId}:`, error); return points.length > 0 ? points : []; } return points;
   };
   generatePoints = function() {
    console.log("Generating points..."); if (!svgLayer || !svgRoot || userPathElements.length === 0) { alert("SVG not placed or no vector elements."); return; } const distanceParams = getDistanceParams(); if (!distanceParams) { return; } generatedPoints = []; pointMarkers.forEach(marker => map.removeLayer(marker)); pointMarkers = []; let totalPointsGenerated = 0, elementsProcessed = 0, elementsSkipped = 0; const allGeneratedPoints = []; userPathElements.forEach((element, index) => { const elementId = element.id || `(no id, index ${index})`; const elementType = element.tagName.toLowerCase(); const pathData = _getPathDataFromElement(element); if (pathData) { const pointsForThisPath = _generatePointsForPath(pathData, distanceParams.mode, distanceParams.options, { sourceIndex: index, sourceId: elementId, sourceTag: elementType }); if (pointsForThisPath.length > 0) { allGeneratedPoints.push(...pointsForThisPath); totalPointsGenerated += pointsForThisPath.length; elementsProcessed++; } else { elementsProcessed++; } } else { elementsSkipped++; } }); generatedPoints = allGeneratedPoints; console.log(`Summary: Total=${totalPointsGenerated}, Processed=${elementsProcessed}, Skipped=${elementsSkipped}`); if (totalPointsGenerated > 0) { drawGeneratedPoints(); alert(`Generated ${totalPointsGenerated} points from ${elementsProcessed} elements.\n(${elementsSkipped} skipped).`); } else { alert(`No points generated. Processed ${elementsProcessed}, Skipped ${elementsSkipped}.`); } updateUI();
   };
   // End explicit copy
   
     // 8️⃣ Placing the SVG Layer on the Map

  function placeSVGOnMap() {
    console.log("Placing SVG on map...");
    if (!isSvgDataLoaded || !loadedSvgText) {
        alert("SVG data is not ready. Please wait or check for loading errors.");
        return;
    }

    // --- Cleanup previous instance if any ---
    if (svgLayer) { map.removeLayer(svgLayer); svgLayer = null; }
    if (svgRoot) {
        // Basic cleanup - remove listeners if possible
        if (svgGroup && typeof svgGroup.off === 'function') { svgGroup.off('.draghandler'); }
        // More complex cleanup might involve removing the SVG node itself, but nulling refs is often enough
        svgRoot = null;
        svgGroup = null;
    }
    userPathElements = []; // Reset elements list for the new instance
    generatedPoints = []; // Clear any previously generated points
    pointMarkers.forEach(marker => map.removeLayer(marker)); pointMarkers = [];
    currentRotation = 0; currentScale = 1; // Reset transforms for the new instance

    // --- Parse the stored SVG text again ---
    let parsedSVG;
    try {
        const parser = new DOMParser();
        const doc = parser.parseFromString(loadedSvgText, "image/svg+xml");
        // No need to re-check parser errors if processLoadedSVGData succeeded
        parsedSVG = doc.documentElement;
    } catch (error) {
         alert("Error re-parsing stored SVG text: " + error.message);
         return;
    }

    // --- Prepare SVG Element attributes ---
    // Use stored dimensions
    parsedSVG.setAttribute('viewBox', `0 0 ${localSVGWidth} ${localSVGHeight}`);
    parsedSVG.setAttribute('width', '100%');
    parsedSVG.setAttribute('height', '100%');
    parsedSVG.setAttribute('preserveAspectRatio', 'xMidYMid meet');
    parsedSVG.style.overflow = 'visible';

    // --- Calculate placement bounds based on CURRENT map view ---
    const mapCenter = map.getCenter();
    const currentZoom = map.getZoom();
    const mapSize = map.getSize();

    // Use a fraction of map dimensions or SVG dimensions for initial size
    const initialPixelWidth = Math.min(mapSize.x * 0.6, mapSize.y * 0.6 * (localSVGWidth / localSVGHeight) , 600); // Consistent sizing logic
    const initialPixelHeight = initialPixelWidth * (localSVGHeight / localSVGWidth);

    const centerPoint = map.project(mapCenter, currentZoom); // Use project for center point
    const nwPoint = centerPoint.subtract([initialPixelWidth / 2, initialPixelHeight / 2]);
    const sePoint = centerPoint.add([initialPixelWidth / 2, initialPixelHeight / 2]);

    // Ensure unproject uses the *current* zoom
    const initialBounds = L.latLngBounds(
        map.unproject(nwPoint, currentZoom),
        map.unproject(sePoint, currentZoom)
    );
    console.log("Placing SVG with Bounds:", initialBounds);

    // --- Create and Add Leaflet Layer ---
    svgLayer = L.customSvgLayer(parsedSVG, initialBounds);
    svgLayer.addTo(map);
    // Optional: Zoom/pan map slightly to fit the placed SVG?
    // map.fitBounds(initialBounds, { padding: [20, 20] }); // Uncomment if desired

    // --- Initialize svg.js ---
    svgRoot = SVG(parsedSVG);
    if (!svgRoot) { console.error("Failed svg.js init on placement!"); return; }
    svgGroup = svgRoot.group().id('svg-content-group');

    // Move content into the group (important for the newly created elements)
    let contentMoved = false;
    Array.from(parsedSVG.childNodes).forEach(node => {
        if (node.nodeType === 1 && node !== svgGroup.node &&
            !['defs', 'style', 'metadata', 'title', 'desc', 'script'].includes(node.nodeName.toLowerCase())) {
            try { svgGroup.add(SVG(node)); contentMoved = true; } catch (e) { console.warn("Cannot add to group on placement:", node, e); }
        }
    });
    if (!contentMoved) console.warn("No content moved to group on placement.");

    // --- Apply Initial Transform ---
    applyTransform();

    // --- Setup Draggability on the Group ---
    if (svgGroup && typeof svgGroup.draggable === 'function') {
        svgGroup.draggable() // Attach to the new group
          .on('dragstart.draghandler', e => { /* ... same drag handler ... */
                map.dragging.disable();
                if (e.detail && e.detail.event) L.DomEvent.stopPropagation(e.detail.event);
                e.detail.handler.el.remember('_dragStartBounds', svgLayer.getBounds());
                if (svgRoot && svgRoot.node) svgRoot.node.style.cursor = 'grabbing';
           })
          .on('dragmove.draghandler', e => { /* ... same drag handler ... */
                 if (e.detail && e.detail.event) L.DomEvent.stopPropagation(e.detail.event);
                const startBounds = e.detail.handler.el.remember('_dragStartBounds');
                if (!startBounds) return;
                 const { x: dx, y: dy } = e.detail.delta;
                 if (typeof dx !== 'number' || typeof dy !== 'number') return;
                const nwPointStart = map.latLngToLayerPoint(startBounds.getNorthWest());
                const sePointStart = map.latLngToLayerPoint(startBounds.getSouthEast());
                const nwPointNew = nwPointStart.add([dx, dy]);
                const sePointNew = sePointStart.add([dx, dy]);
                const newBounds = L.latLngBounds(map.layerPointToLatLng(nwPointNew), map.layerPointToLatLng(sePointNew));
                svgLayer.setBounds(newBounds);
                 if (generatedPoints.length > 0) { drawGeneratedPoints(); }
           })
          .on('dragend.draghandler', e => { /* ... same drag handler ... */
                map.dragging.enable();
                if (e.detail && e.detail.event) L.DomEvent.stopPropagation(e.detail.event);
                e.detail.handler.el.forget('_dragStartBounds');
                if (svgRoot && svgRoot.node) svgRoot.node.style.cursor = 'grab';
                if (generatedPoints.length > 0) { drawGeneratedPoints(); }
           });
        console.log("Draggable handler attached to placed svgGroup.");
    } else { console.error("svgGroup.draggable missing on placement."); }

    // --- Find Usable Vector Elements *for this instance* ---
    userPathElements = Array.from(svgRoot.node.querySelectorAll('path, line, polyline, polygon, rect, circle, ellipse'));
    console.log(`Found ${userPathElements.length} vector elements in placed SVG.`);
    if (userPathElements.length === 0) { alert("Warning: No usable vector shapes found in placed SVG."); }

    // --- Update UI to enable controls ---
    updateUI();
    console.log("SVG placement complete.");
  }


  // 9️⃣ Draw Point Markers on Map (_getTransformedLatLng, drawGeneratedPoints - no changes)
  function _getTransformedLatLng(point) { /* ... */ }
  function drawGeneratedPoints() { /* ... */ }
   // Explicitly copy implementation from previous working version
   _getTransformedLatLng = function(point) {
    if (!svgRoot || !svgGroup || !map) { return null; } const svgElement = svgRoot.node; const groupNode = svgGroup.node; const screenCTM = groupNode.getScreenCTM(); if (!screenCTM) { return null; } const svgPoint = svgElement.createSVGPoint(); svgPoint.x = point.x; svgPoint.y = point.y; try { const transformedPoint = svgPoint.matrixTransform(screenCTM); const mapContainerRect = map.getContainer().getBoundingClientRect(); const containerX = transformedPoint.x - mapContainerRect.left; const containerY = transformedPoint.y - mapContainerRect.top; return map.containerPointToLatLng([containerX, containerY]); } catch (e) { console.error("Error transforming point:", e, point); return null; }
   };
   drawGeneratedPoints = function() {
    pointMarkers.forEach(marker => map.removeLayer(marker)); pointMarkers = []; if (!generatedPoints || generatedPoints.length === 0 || !svgGroup) { return; } let failedTransforms = 0; generatedPoints.forEach((point, index) => { const latLng = _getTransformedLatLng(point); if (latLng) { const marker = L.circleMarker(latLng, POINT_MARKER_OPTIONS).bindTooltip(`Point ${index + 1}<br>Source: ${point.sourceTag} ${point.sourceId}`); marker.addTo(map); pointMarkers.push(marker); } else { failedTransforms++; } }); if (failedTransforms > 0) { console.warn(`Failed to draw ${failedTransforms} points.`); }
   };
   // End explicit copy


  // 🔟 Export Functionality (KML only - buildDataForKML, exportKML - no changes)
    // Function to build data structure for KML (simpler than full GeoJSON if only for KML)
  function buildDataForKML() {
    if (!generatedPoints || generatedPoints.length === 0) { return null; }
    if (!svgGroup) { return null; }

    const features = [];
    generatedPoints.forEach((point, index) => {
        const latLng = _getTransformedLatLng(point);
        if (latLng) {
            features.push({
                // These are properties tokml will look for based on options
                name: (index + 1).toString(), // MODIFIED: Just the number
                description: `Source: ${point.sourceTag} ${point.sourceId} (SVG Coords: x=${point.x.toFixed(2)}, y=${point.y.toFixed(2)})`,
                // Geometry needs to be structured for tokml, even if not full GeoJSON
                geometry: {
                    type: "Point",
                    coordinates: [latLng.lng, latLng.lat]
                },
                // Keep original properties if needed for KML extended data
                properties: { // This 'properties' sub-object is what tokml maps
                    index: index + 1,
                    sourceIndex: point.sourceIndex,
                    sourceId: point.sourceId,
                    sourceTag: point.sourceTag
                }
            });
        }
    });
    if (features.length === 0 && generatedPoints.length > 0) { return null; }
    // tokml expects a GeoJSON-like FeatureCollection structure
    return { type: "FeatureCollection", features: features };
  }
  function exportKML() { /* ... */ }
   // Explicitly copy implementation from previous working version
   buildDataForKML = function() {
    if (!generatedPoints || generatedPoints.length === 0 || !svgGroup) { return null; } const features = [];
    generatedPoints.forEach((point, index) => { const latLng = _getTransformedLatLng(point); if (latLng) { features.push({ name: `Point ${index + 1}`, description: `Source: ${point.sourceTag} ${point.sourceId} (SVG Coords: x=${point.x.toFixed(2)}, y=${point.y.toFixed(2)})`, geometry: { type: "Point", coordinates: [latLng.lng, latLng.lat] }, properties: { index: index + 1, sourceIndex: point.sourceIndex, sourceId: point.sourceId, sourceTag: point.sourceTag } }); } }); if (features.length === 0 && generatedPoints.length > 0) { return null; } return { type: "FeatureCollection", features: features };
   };
   exportKML = function() {
    const dataForKml = buildDataForKML(); if (!dataForKml || !dataForKml.features || dataForKml.features.length === 0) { alert("No point data to export."); return; } if (typeof tokml === 'undefined') { alert("tokml library missing."); return; } try { const kmlString = tokml(dataForKml, { name: 'name', description: 'description' }); const blob = new Blob([kmlString], { type: "application/vnd.google-earth.kml+xml" }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = "svg_points.kml"; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); console.log("KML export initiated."); } catch (error) { console.error("Error KML export:", error); alert("Error creating KML file."); }
   };
   // End explicit copy


  // --- Initialize after DOM is ready ---
  document.addEventListener('DOMContentLoaded', () => {
    if (!checkDependencies()) {
      alert("Dependencies missing. Check console.");
      return;
    }
    initMap();
    loadAndProcessSVG(SVG_PATH_TO_LOAD); // Load SVG data on page load

    // Setup button listeners
    document.getElementById('btnPlaceSVG').addEventListener('click', placeSVGOnMap); // New button listener
    document.getElementById('btnGeneratePoints').addEventListener('click', generatePoints);
    document.getElementById('btnExportKML').addEventListener('click', exportKML);
    document.getElementById('btnRotateLeft').addEventListener('click', () => rotateSVG(-10));
    document.getElementById('btnRotateRight').addEventListener('click', () => rotateSVG(10));
    document.getElementById('btnScaleUp').addEventListener('click', () => scaleSVG(1.1));
    document.getElementById('btnScaleDown').addEventListener('click', () => scaleSVG(0.9));

    updateUI(); // Set initial UI state (Place button disabled until load finishes)
  });

  </script> <!-- // <-- END OF SINGLE SCRIPT BLOCK -->
  
  </body>
</html>
